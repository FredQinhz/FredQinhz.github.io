<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>设计模式复习 | Fred's Blog</title><meta name="author" content="Fred Qin"><meta name="copyright" content="Fred Qin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="设计模式部分总结，请结合其他复习资料食用 :)"><meta property="og:type" content="article"><meta property="og:title" content="设计模式复习"><meta property="og:url" content="https://fredqinhz.github.io/posts/5db50ef3.html"><meta property="og:site_name" content="Fred&#39;s Blog"><meta property="og:description" content="设计模式部分总结，请结合其他复习资料食用 :)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://fredq.oss-cn-nanjing.aliyuncs.com/cover/cover1.jpg"><meta property="article:published_time" content="2024-08-17T04:56:30.000Z"><meta property="article:modified_time" content="2024-09-22T09:28:19.945Z"><meta property="article:author" content="Fred Qin"><meta property="article:tag" content="期末复习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://fredq.oss-cn-nanjing.aliyuncs.com/cover/cover1.jpg"><link rel="shortcut icon" href="https://fredq.oss-cn-nanjing.aliyuncs.com/others/avatar.jpg"><link rel="canonical" href="https://fredqinhz.github.io/posts/5db50ef3.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Fred Qin","link":"链接: ","source":"来源: Fred's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"设计模式复习",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-09-22 17:28:19"}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/icon.css"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/others/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/photography/"><i class="fa-fw fas fa-camera"></i> <span>摄影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-md"></i> <span>关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background:0 0"><nav id="nav"><span id="blog-info"><a href="/" title="Fred's Blog"><span class="site-name">Fred's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/photography/"><i class="fa-fw fas fa-camera"></i> <span>摄影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-md"></i> <span>关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">设计模式复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-17T04:56:30.000Z" title="发表于 2024-08-17 12:56:30">2024-08-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-22T09:28:19.945Z" title="更新于 2024-09-22 17:28:19">2024-09-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2024Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">2024Spring-软件系统设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="设计模式复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="软件模式"><a href="#软件模式" class="headerlink" title="软件模式"></a>软件模式</h2><ol><li>软件模式是将模式的一般概念应用于软件开发领域，即<strong>软件开发的总体指导思路或参照样板</strong>。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，实际上，<strong>在软件生存期的每一个阶段都存在着一些被认同的模式</strong>。</li><li>软件模式可以认为是<strong>对软件开发这一特定“问题”的“解法”的某种统一表示</strong>，<strong>软件模式等于一定条件下的出现的问题以及解法</strong>。软件模式的基础结构由 4 个部分构成：<strong>问题描述、前提条件（环境或约束条件）、解法和效果</strong>。</li></ol><ul><li>能讲清为什么使用某个模式<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image.png"></li><li>软件模式与具体的应用领域无关，在模式发现过程中需要遵循<strong>大三律（Rule of Three）</strong>，即只有经过<strong>三个以上不同类型（或不同领域）</strong>的系统的校验，一个解决方案才能从候选模式升格为模式。</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="设计模式的定义"><a href="#设计模式的定义" class="headerlink" title="设计模式的定义"></a>设计模式的定义</h3><p><strong>设计模式（Design Pattern）</strong>是一套<strong>被反复使用</strong>、<strong>多数人知晓的</strong>、<strong>经过分类编目的</strong>、<strong>代码设计经验的总结</strong>，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p><h3 id="设计模式的基本要素"><a href="#设计模式的基本要素" class="headerlink" title="设计模式的基本要素"></a>设计模式的基本要素</h3><p>设计模式一般有如下几个基本要素：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，其中的关键元素包括以下四个方面：</p><ul><li><strong>模式名称</strong>（Pattern name）</li><li><strong>问题</strong>（Problem）</li><li><strong>解决方案</strong>（Solution）</li><li><strong>效果</strong>（Consequences）</li></ul><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><ul><li><p>根据其<strong>目的</strong>（模式是用来做什么的）可分为**创建型(Creational)，结构型(Structural)和行为型(Behavioral)**三种：</p><ul><li><strong>创建型</strong>模式主要用于<strong>创建对象</strong>。</li><li><strong>结构型</strong>模式主要用于<strong>处理类或对象的组合</strong>。</li><li><strong>行为型</strong>模式主要用于<strong>描述对类或对象怎样交互和怎样分配职责</strong>。</li></ul></li><li><p>根据<strong>范围</strong>，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为<strong>类模式</strong>和<strong>对象</strong>模式两种：</p><ul><li>类模式<strong>处理类和子类之间的关系</strong>，这些关系通过继承建立，在编译时刻就被确定下来，是属于<strong>静态</strong>的。</li><li>对象模式<strong>处理对象间的关系</strong>，这些关系在运行时刻变化，更具<strong>动态</strong>性。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-1.png" alt="alt text"></li></ul><blockquote><p>模板方法为什么是行为型模式：子类控制父类的行为</p></blockquote></li></ul><h3 id="设计模式与类库框架"><a href="#设计模式与类库框架" class="headerlink" title="设计模式与类库框架"></a>设计模式与类库框架</h3><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-2.png" alt="alt text"></p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul><li>对于面向对象的软件系统设计来说，在支持可维护性的同时，需要提高系统的可复用性。</li><li>软件的复用可以提高软件的开发效率，提高软件质量，节约开发成本，恰当的复用还可以改善系统的可维护性。</li></ul><ol><li><p><strong>单一职责原则</strong>：要求在软件系统中，一个类只负责一个功能领域中的相应职责。</p></li><li><p><strong>开闭原则</strong>：要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</p></li><li><p><strong>里氏代换原则</strong>：可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</p><blockquote><p>因此在程序中尽量使用基类类型来对对象进行定义，</p><p>而在运行时再确定其子类类型，用子类对象来替换父类对象</p><p>实现开闭原则的重要方式之一</p></blockquote></li><li><p><strong>依赖倒转原则</strong>：要求抽象不应该依赖于细节，细节应该依赖于抽象；要针对接口编程，不要针对实现编程。</p></li><li><p><strong>接口隔离原则</strong>：要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</p><blockquote><p>使用接口隔离原则拆分接口时，首先必须满足单一职责原则</p></blockquote></li><li><p><strong>合成复用原则</strong>：要求复用时尽量使用对象组合，而不使用继承。</p><blockquote><p>通过<strong>关联关系</strong>（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分</p><p>新对象通过<strong>委派调用</strong>已有对象的方法达到复用其已有功能的目的</p></blockquote></li><li><p><strong>迪米特法则</strong>（<strong>最小知识原则</strong>）：要求一个软件实体应当尽可能少的与其他实体发生相互作用。</p></li></ol><h3 id="设计原则之间的关系"><a href="#设计原则之间的关系" class="headerlink" title="设计原则之间的关系"></a>设计原则之间的关系</h3><ul><li>目标：开闭原则</li><li>指导：迪米特法则（最小知识原则）</li><li>基础：单一职责原则、可变性封装原则</li><li>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</li></ul><h2 id="表驱动法（不考）"><a href="#表驱动法（不考）" class="headerlink" title="表驱动法（不考）"></a>表驱动法（不考）</h2><ul><li>目标</li><li>原理</li><li>如何快速从表中查询条目<ul><li>直接访问</li><li>索引访问</li><li>阶梯访问</li></ul></li></ul><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="工厂方法模式（类模式）"><a href="#工厂方法模式（类模式）" class="headerlink" title="工厂方法模式（类模式）"></a>工厂方法模式（类模式）</h3><blockquote><p>整理不动了，去看ppt或者博客吧</p><p><a target="_blank" rel="noopener" href="https://eaglebear2002.github.io/2023Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1-03-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">软件详细设计-03-工厂模式 | EagleBear2002 的博客</a></p></blockquote><h3 id="抽象工厂模式（对象模式）"><a href="#抽象工厂模式（对象模式）" class="headerlink" title="抽象工厂模式（对象模式）"></a>抽象工厂模式（对象模式）</h3><blockquote><p>整理不动了，去看ppt或者博客吧</p><p><a target="_blank" rel="noopener" href="https://eaglebear2002.github.io/2023Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1-03-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">软件详细设计-03-工厂模式 | EagleBear2002 的博客</a></p></blockquote><h3 id="原型模式-Prototype-Pattern"><a href="#原型模式-Prototype-Pattern" class="headerlink" title="原型模式 Prototype Pattern"></a>原型模式 Prototype Pattern</h3><h4 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h4><ul><li>原型模式是一种<strong>对象创建型</strong>模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节。</li></ul><h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><ul><li>模式结构<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-3.png" alt="alt text"></li><li>包含如下角色<ul><li><code>Prototype</code>：抽象原型类</li><li><code>ConcretePrototype</code>：具体原型类</li><li><code>Client</code>：客户类</li></ul></li></ul><h4 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h4><ul><li>在原型模式结构中定义了一个抽象原型类，所有的 Java 类都继承自 <code>java.lang.Object</code>，而 Object 类提供一个 <code>clone()</code> 方法，可以将一个 Java 对象复制一份。</li><li>能够实现克隆的 Java 类必须实现一个标识接口 <code>Cloneable</code>，表示这个 Java 类支持复制。如果一个类没有实现这个接口但是调用了 <code>clone()</code> 方法，Java 编译器将抛出一个 <code>CloneNotSupportedException</code> 异常。</li><li>通原型模式可以分为两种形式：深克隆【成员对象也克隆】和浅克隆【成员对象不克隆】。</li><li>Java 语言提供的 <code>clone()</code> 方法将对象复制了一份并返回给调用者。一般而言，<code>clone()</code> 方法满足：<ul><li>对任何的对象 <code>x</code>，都有 <code>x.clone() != x</code>，即克隆对象与原对象不是同一个对象。</li><li>对任何的对象 <code>x</code>，都有 <code>x.clone().getClass()==x.getClass()</code>，即克隆对象与原对象的类型一样。</li><li>如果对象 <code>x</code> 的 <code>equals()</code> 方法定义恰当，那么 <code>x.clone().equals(x)</code> 应该成立。</li></ul></li></ul><h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><h5 id="实例一：邮件复制（浅克隆）"><a href="#实例一：邮件复制（浅克隆）" class="headerlink" title="实例一：邮件复制（浅克隆）"></a>实例一：邮件复制（浅克隆）</h5><ul><li>由于邮件对象包含的内容较多（如发送者、接收者、标题、内容、日期、附件等），某系统中现需要提供一个邮件复制功能，对于已经创建好的邮件对象，可以通过复制的方式创建一个新的邮件对象，如果需要改变某部分内容，无须修改原始的邮件对象，只需要修改复制后得到的邮件对象即可。使用原型模式设计该系统。在本实例中使用浅克隆实现邮件复制，即复制邮件（Email）的同时不复制附件（Attachment）。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-5.png" alt="alt text"></li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点：<ul><li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。</li><li>可以动态增加或减少产品类。</li><li>原型模式提供了简化的创建结构。</li><li>可以使用深克隆的方式保存对象的状态。</li></ul></li><li>缺点：<ul><li>需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。</li><li>在实现深克隆时需要编写较为复杂的代码。</li></ul></li><li>适用环境：<ul><li><strong>创建新对象成本较大</strong>，新的对象可以通过原型模式对已有对象进行复制来获得，如果是<strong>相似对象</strong>，则可以对其属性稍作修改。</li><li>如果系统要<strong>保存对象的状态</strong>，<strong>而对象的状态变化很小</strong>，或者<strong>对象本身占内存不大</strong>的时候，也可以使用<strong>原型模式</strong>配合<strong>备忘录模式</strong>来应用。相反，如果<strong>对象的状态变化很大</strong>，或者<strong>对象占用的内存很大</strong>，那么采用<strong>状态模式</strong>会比原型模式更好。</li><li>需要<strong>避免</strong>使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li></ul></li></ul><h4 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h4><ul><li>创建新对象成本较大，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其属性稍作修改。</li><li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。</li><li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li></ul><h4 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h4><h5 id="带原型管理器的原型模式"><a href="#带原型管理器的原型模式" class="headerlink" title="带原型管理器的原型模式"></a>带原型管理器的原型模式</h5><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-36.png" alt="img"></p><h5 id="相似对象的复制"><a href="#相似对象的复制" class="headerlink" title="相似对象的复制"></a>相似对象的复制</h5><p>很多情况下，复制所得到的对象与原型对象并不是完全相同的，它们的某些属性值存在异同。通过原型模式获得相同对象后可以再对其属性进行修改，从而获取所需对象。如多个学生对象的信息的区别在于性别、姓名和年龄，而专业、学院、学校等信息都相同，为了简化创建过程，可以通过原型模式来实现相似对象的复制。</p><h4 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h4><ul><li>原型模式应用于很多软件中，如果每次创建一个对象要花大量时间，原型模式是最好的解决方案。很多软件提供的复制（<code>Ctrl + C</code>）和粘贴（<code>Ctrl + V</code>）操作就是原型模式的应用，复制得到的对象与原型对象是两个类型相同但内存地址不同的对象，通过原型模式可以大大提高对象的创建效率。</li><li>在 Struts2 中为了保证线程的安全性，Action 对象的创建使用了原型模式，访问一个已经存在的 Action 对象时将通过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个 Action 中都有自己的成员变量，避免 Struts1 因使用单例模式而导致的并发和同步问题。</li><li>在 Spring 中，用户也可以采用原型模式来创建新的 bean 实例，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。</li></ul><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式 Adapter Pattern"></a>适配器模式 Adapter Pattern</h3><h4 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h4><ul><li>在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。</li><li>通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的<strong>类可以满足客户类的功能需要</strong>，但是它所<strong>提供的接口不一定是客户类所期望的</strong>，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。</li><li>在这种情况下，<strong>现有的接口需要转化为客户类期望的接口</strong>，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，<strong>适配器模式</strong>可以完成这样的转化。</li><li>在适配器模式中可以<strong>定义一个包装类</strong>，包装不兼容接口的对象，这个包装类指的就是适配器（Adapter），它所包装的对象就是适配者（Adaptee），即被适配的类。</li><li>适配器<strong>提供客户类需要的接口</strong>，适配器的实现就是<strong>把客户类的请求转化为对适配者的相应接口的调用</strong>。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</li></ul><h4 id="模式定义-1"><a href="#模式定义-1" class="headerlink" title="模式定义"></a>模式定义</h4><ul><li>Adapter Pattern：<strong>将一个接口转换成客户希望的另一个接口</strong>，适配器模式<strong>使接口不兼容的那些类可以一起工作</strong>，其别名为包装器（Wrapper）。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li></ul><h4 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h4><ul><li>模式结构：<ul><li>对象适配器：<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-18.png" alt="alt text"></li><li>类适配器：<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-19.png" alt="alt text"></li></ul></li><li>适配器模式包含如下角色：<ol><li><code>Target</code>：目标抽象类</li><li><code>Adapter</code>：适配器类</li><li><code>Adaptee</code>：适配者类</li><li><code>Client</code>：客户类</li></ol></li></ul><h4 id="模式分析-1"><a href="#模式分析-1" class="headerlink" title="模式分析"></a>模式分析</h4><ul><li><p>典型的类适配器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的对象适配器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h4><h5 id="仿生机器人"><a href="#仿生机器人" class="headerlink" title="仿生机器人"></a>仿生机器人</h5><p>现需要设计一个可以模拟各种动物行为的机器人，在机器人中定义了一系列方法，如机器人叫喊方法 <code>cry()</code>、机器人移动方法 <code>move()</code> 等。如果希望在不修改已有代码的基础上使得机器人能够像狗一样叫，像狗一样跑，使用适配器模式进行系统设计。</p><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-34.png" alt="alt text"></p><h5 id="加密适配器"><a href="#加密适配器" class="headerlink" title="加密适配器"></a>加密适配器</h5><p>某系统需要提供一个加密模块，将用户信息（如密码等机密信息）加密之后再存储在数据库中，系统已经定义好了数据库操作类。为了提高开发效率，现需要重用已有的加密算法，这些算法封装在一些由第三方提供的类中，有些甚至没有源代码。使用适配器模式设计该加密模块，实现在不修改现有类的基础上重用第三方加密方法。</p><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-35.png" alt="alt text"></p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>适配器模式优点：</p><ul><li><strong>将目标类和适配者类解耦</strong>，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li><li><strong>增加了类的透明性和复用性</strong>，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li><li><strong>灵活性和扩展性都非常好</strong>，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul></li><li><p>类适配器模式还具有如下优点：</p><ul><li>由于适配器类是适配者类的子类，因此可以在<strong>适配器类中置换一些适配者的方法</strong>，使得适配器的灵活性更强。</li></ul></li><li><p>类适配器模式的缺点如下：</p><ul><li>对于 Java、C# 等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，<strong>其使用有一定的局限性</strong>，不能将一个适配者类和它的子类都适配到目标接口。</li></ul></li><li><p>对象适配器模式还具有如下优点：</p><ul><li>一个对象适配器<strong>可以把多个不同的适配者适配到同一个目标</strong>，也就是说，同一个适配器<strong>可以把适配者类和它的子类都适配到目标接口</strong>。</li></ul></li><li><p>对象适配器模式的缺点如下：</p><ul><li>与类适配器模式相比，<strong>要想置换适配者类的方法就不容易</strong>。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li></ul></li></ul><h4 id="适用环境-1"><a href="#适用环境-1" class="headerlink" title="适用环境"></a>适用环境</h4><ul><li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ul><h4 id="模式应用-1"><a href="#模式应用-1" class="headerlink" title="模式应用"></a>模式应用</h4><ul><li><p>在 JDK 类库中也定义了一系列适配器类，如在 <code>com.sun.imageio.plugins.common</code> 包中定义的<code>InputStreamAdapter</code>类，用于包装 <code>ImageInputStream</code> 接口及其子类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamAdapter</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">    ImageInputStream stream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InputStreamAdapter</span><span class="params">(ImageInputStream stream)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.stream = stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> stream.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> stream.read(b, off, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="组合模式-Composite-Pattern"><a href="#组合模式-Composite-Pattern" class="headerlink" title="组合模式 Composite Pattern"></a>组合模式 Composite Pattern</h3><h4 id="模式动机-1"><a href="#模式动机-1" class="headerlink" title="模式动机"></a>模式动机</h4><ul><li>对于<strong>树形结构</strong>，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，如子文件夹和文件）并调用执行。<strong>（递归调用）</strong></li><li>由于容器对象和叶子对象在功能上的区别，在使用这些对象的客户端代码中必须<strong>有区别地对待容器对象和叶子对象</strong>，而实际上<strong>大多数情况下客户端希望一致地处理它们</strong>，<strong>因为对于这些对象的区别对待将会使得程序非常复杂</strong>。</li><li>组合模式描述了<strong>如何将容器对象和叶子对象进行递归组合</strong>，使得<strong>用户在使用时无须对它们进行区分</strong>，可以<strong>一致地对待容器对象和叶子对象</strong>，这就是组合模式的模式动机。</li></ul><h4 id="模式定义-2"><a href="#模式定义-2" class="headerlink" title="模式定义"></a>模式定义</h4><ul><li>组合模式（Composite Pattern）：组合多个对象形成<strong>树形结构以表示“整体-部分”的结构层次</strong>。组合模式对<strong>单个对象（即叶子对象）</strong>和<strong>组合对象（即容器对象）</strong>的使用具有<strong>一致性</strong>。</li><li>组合模式又可以称为<strong>整体-部分（Part-Whole）模式</strong>，属于对象的结构模式，它<strong>将对象组织到树结构中，可以用来描述整体与部分的关系</strong>。</li></ul><h4 id="模式结构-2"><a href="#模式结构-2" class="headerlink" title="模式结构"></a>模式结构</h4><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-20.png" alt="alt text"></p><ul><li>组合模式包含如下角色：<ol><li><code>Component</code>：抽象构件</li><li><code>Leaf</code>：叶子构件</li><li><code>Composite</code>：容器构件</li><li><code>Client</code>：客户类</li></ol></li></ul><h4 id="模式分析-2"><a href="#模式分析-2" class="headerlink" title="模式分析"></a>模式分析</h4><ul><li><p>组合模式的关键是<strong>定义了一个抽象构件类</strong>，它既可以代表叶子，又可以代表容器，而<strong>客户端针对该抽象构件类进行编程</strong>，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。</p></li><li><p>同时<strong>容器对象与抽象构件类之间还建立一个聚合关联关系</strong>，在容器对象中既可以包含叶子，也可以包含容器，以此实现<strong>递归组合，形成一个树形结构</strong>。</p></li><li><p>文件系统组合模式结构图：<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-21.png" alt="alt text"></p></li><li><p>典型的抽象构件角色代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的叶子构件角色代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span></span><br><span class="line">    &#123; <span class="comment">//异常处理或错误提示 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span></span><br><span class="line">    &#123; <span class="comment">//异常处理或错误提示 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123; <span class="comment">//异常处理或错误提示 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//实现代码</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的容器构件角色代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        list.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        (Component) list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : list) &#123;</span><br><span class="line">            ((Component) obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实例分析-2"><a href="#实例分析-2" class="headerlink" title="实例分析"></a>实例分析</h4><h5 id="水果盘"><a href="#水果盘" class="headerlink" title="水果盘"></a>水果盘</h5><ul><li>在水果盘（Plate）中有一些水果，如苹果（Apple）、香蕉（Banana）、梨子（Pear），当然大水果盘中还可以有小水果盘，现需要对盘中的水果进行遍历（吃），当然如果对一个水果盘执行”吃”方法，实际上就是吃其中的水果。使用组合模式模拟该场景。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-22.png" alt="alt text"></li></ul><h5 id="文件浏览"><a href="#文件浏览" class="headerlink" title="文件浏览"></a>文件浏览</h5><ul><li>文件有不同类型，不同类型的文件其浏览方式有所区别，如文本文件和图片文件的浏览方式就不相同。对文件夹的浏览实际上就是对其中所包含文件的浏览，而客户端可以一致地对文件和文件夹进行操作，无须关心它们的区别。使用组合模式来模拟文件的浏览操作。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-23.png" alt="alt text"></li></ul><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点：</p><ul><li>可以清楚地<strong>定义分层次的复杂对象</strong>，表示对象的全部或部分层次，使得增加新构件也更容易。</li><li>客户端调用简单，<strong>客户端可以一致的使用组合结构或其中单个对象</strong>。</li><li>定义了包含叶子对象和容器对象的<strong>类层次结构</strong>，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，<strong>可以形成复杂的树形结构</strong>。</li><li><strong>更容易在组合体内加入对象构件</strong>，客户端不必因为加入了新的对象构件而更改原有代码。组合模式</li></ul></li><li><p>缺点：</p><ul><li><strong>使设计变得更加抽象</strong>，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。</li><li>增加新构件时可能会产生一些问题，<strong>很难对容器中的构件类型进行限制</strong>。</li></ul></li></ul><h4 id="适用环境-2"><a href="#适用环境-2" class="headerlink" title="适用环境"></a>适用环境</h4><ul><li>需要表示一个<strong>对象整体或部分层次</strong>，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。</li><li>让客户能够忽略不同对象层次的变化，<strong>客户端可以针对抽象构件编程，无须关心对象层次结构的细节</strong>。</li><li><strong>对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们</strong>。</li></ul><h4 id="模式应用-2"><a href="#模式应用-2" class="headerlink" title="模式应用"></a>模式应用</h4><ul><li><p>XML 文档解析</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>Carson<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span> <span class="attr">format</span>=<span class="string">&quot;dollar&quot;</span>&gt;</span>31.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pubdate</span>&gt;</span>05/01/2001<span class="tag">&lt;/<span class="name">pubdate</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pubinfo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">publisher</span>&gt;</span>MSPress<span class="tag">&lt;/<span class="name">publisher</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">state</span>&gt;</span>WA<span class="tag">&lt;/<span class="name">state</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pubinfo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/xml.png" alt="img"></p></li><li><p>操作系统中的目录结构是一个树形结构，因此在对文件和文件夹进行操作时可以应用组合模式，例如杀毒软件在查毒或杀毒时，既可以针对一个具体文件，也可以针对一个目录。如果是对目录查毒或杀毒，将递归处理目录中的每一个子目录和文件。</p></li><li><p>JDK 的 AWT&#x2F;Swing 是组合模式在 Java 类库中的一个典型实际应用。</p><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/AWTSwing.png" alt="img"></p></li></ul><h4 id="模式扩展-1"><a href="#模式扩展-1" class="headerlink" title="模式扩展"></a>模式扩展</h4><ul><li>透明组合模式：所有组件（无论是叶子节点还是组合节点）都共享相同的接口。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-24.png" alt="alt text"></li><li>安全组合模式（违反了里氏代换原则）：组件接口被分为两类：一个用于叶子节点，一个用于组合节点。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-25.png" alt="alt text"></li></ul><h3 id="装饰模式-Decorator-Pattern"><a href="#装饰模式-Decorator-Pattern" class="headerlink" title="装饰模式 Decorator Pattern"></a>装饰模式 Decorator Pattern</h3><h4 id="模式动机-2"><a href="#模式动机-2" class="headerlink" title="模式动机"></a>模式动机</h4><ul><li>一般有两种方式可以实现给一个类或对象增加行为：<ol><li><strong>继承机制</strong>，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li><li><strong>关联机制</strong>，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为。</li></ol></li><li>装饰模式以<strong>对客户透明的方式动态地给一个对象附加上更多的责任</strong>，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在<strong>不需要创造更多子类的情况下</strong>，将对象的<strong>功能加以扩展</strong>。这就是装饰模式的模式动机。</li></ul><h4 id="模式定义-3"><a href="#模式定义-3" class="headerlink" title="模式定义"></a>模式定义</h4><ul><li>Decorator Pattern：<strong>动态地给一个对象增加一些额外的职责</strong>（Responsibility），就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为<strong>包装器</strong>（Wrapper），与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种<strong>对象结构型模式</strong>。</li></ul><h4 id="模式结构-3"><a href="#模式结构-3" class="headerlink" title="模式结构"></a>模式结构</h4><ul><li><p>模式结构：<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-26.png" alt="alt text"></p></li><li><p>装饰模式包含如下角色：</p><ol><li><code>Component</code>：抽象构件</li><li><code>ConcreteComponent</code>：具体构件</li><li><code>Decorator</code>：抽象装饰类</li><li><code>ConcreteDecorator</code>：具体装饰类</li></ol></li></ul><h4 id="模式分析-3"><a href="#模式分析-3" class="headerlink" title="模式分析"></a>模式分析</h4><ul><li><p>与继承关系相比，关联关系的主要优势在于<strong>不会破坏类的封装性</strong>，而且<strong>继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展</strong>。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的<strong>松耦合性</strong>，因此使得<strong>系统更加容易维护</strong>。当然，关联关系的缺点是<strong>比继承关系要创建更多的对象</strong>。</p></li><li><p>使用装饰模式来实现扩展比继承更加灵活，它以<strong>对客户透明的方式动态地给一个对象附加更多的责任</strong>。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</p></li><li><p>典型的抽象装饰类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的具体装饰类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        addedBehavior();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addedBehavior</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新增方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实例分析-3"><a href="#实例分析-3" class="headerlink" title="实例分析"></a>实例分析</h4><h5 id="变形金刚（半透明装饰模式）"><a href="#变形金刚（半透明装饰模式）" class="headerlink" title="变形金刚（半透明装饰模式）"></a>变形金刚（半透明装饰模式）</h5><ul><li>变形金刚在变形之前是一辆汽车，它可以在陆地上移动。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔。<blockquote><p>Q：为什么 <code>Changer</code> 在继承自 <code>Transform</code> 的同时还要有一个 <code>Transform</code>？</p><p>A：因为我们希望 <code>Changer</code> 能够装饰 <code>Car</code> 或其他的 <code>Transform</code> （如果有，例如 <code>Bicycle</code>），因此需要组合一个 <code>transform</code>。</p></blockquote><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-27.png" alt="alt text"></li></ul><h5 id="多重加密系统（透明装饰模式）"><a href="#多重加密系统（透明装饰模式）" class="headerlink" title="多重加密系统（透明装饰模式）"></a>多重加密系统（透明装饰模式）</h5><ul><li>某系统提供了一个数据加密功能，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高级的求模加密。用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加密。现使用装饰模式设计该多重加密系统。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-28.png" alt="alt text"></li></ul><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点：</p><ul><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是<strong>装饰模式可以提供比继承更多的灵活性</strong>。</li><li>可以<strong>通过一种动态的方式来扩展一个对象的功能</strong>，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li><li><strong>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合</strong>。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li><li><strong>具体构件类与具体装饰类可以独立变化</strong>，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，**符合”开闭原则”**。</li></ul></li><li><p>缺点：</p><ul><li>使用装饰模式进行系统设计时将<strong>产生很多小对象</strong>，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着<strong>装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐</strong>。</li></ul></li></ul><h4 id="适用环境-3"><a href="#适用环境-3" class="headerlink" title="适用环境"></a>适用环境</h4><ul><li>在不影响其他对象的情况下，<strong>以动态、透明的方式给单个对象添加职责</strong>。</li><li>需要<strong>动态地给一个对象增加功能</strong>，这些功能也可以动态地被撤销。</li><li><strong>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时</strong>。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如 final 类）。</li></ul><h4 id="模式应用-3"><a href="#模式应用-3" class="headerlink" title="模式应用"></a>模式应用</h4><ul><li><p>在 <code>javax.swing</code> 包中，可以通过装饰模式动态给一些构件增加新的行为或改善其外观显示。</p><ul><li><p>如 JList 构件本身并不支持直接滚动，即没有滚动条，要创建可以滚动的列表，可以使用如下代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JList</span>();</span><br><span class="line"><span class="type">JScrollPane</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JScrollPane</span>(list);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>装饰模式在 JDK 中最经典的实例是 Java IO。</p><ul><li>以 <code>InputStream</code> 为例：<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/inputstream.png" alt="img"></li></ul></li><li><p>抽象装饰类：<code>FilterInputStream</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">FilterInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.in = in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>角色分配：</p><ol><li>抽象构件类：<code>InputStream</code></li><li>具体构件类：<code>FileInputStream</code>、<code>ByteArrayInputStream</code>等</li><li>抽象装饰类：<code>FilterInputStream</code></li><li>具体装饰类：<code>BufferedInputStream</code>、<code>DataInputStream</code>等</li></ol></li><li><p>客户端使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">inFS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;temp/fileSrc.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">inBS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(inFS);</span><br><span class="line"><span class="comment">// 定义一个字节数组，用于存放缓冲数据</span></span><br><span class="line"><span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">inBS.read(data);</span><br></pre></td></tr></table></figure></li></ul><h4 id="模式扩展-2"><a href="#模式扩展-2" class="headerlink" title="模式扩展"></a>模式扩展</h4><ul><li>装饰模式的简化-需要注意的问题：<ul><li><strong>一个装饰类的接口必须与被装饰类的接口保持相同</strong>，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类 Component 作为一个”轻”类，也就是说<strong>不要把太多的逻辑和状态放在具体构件类中</strong>，可以通过装饰类对其进行扩展。</li><li><strong>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类</strong>。</li></ul></li><li>装饰模式的简化<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-29.png" alt="alt text"></li><li>透明装饰模式（多重加密系统）：<ul><li>在<strong>透明</strong>装饰模式中，<strong>要求客户端完全针对抽象编程</strong>，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型。</li></ul></li><li>半透明装饰模式（变形金刚）<ul><li><strong>半透明</strong>（semi-transparent）的装饰模式<strong>允许用户在客户端声明具体装饰者类型的对象</strong>，调用在具体装饰者中新增的方法。</li></ul></li></ul><h3 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式 Facade Pattern"></a>外观模式 Facade Pattern</h3><h4 id="模式动机-3"><a href="#模式动机-3" class="headerlink" title="模式动机"></a>模式动机</h4><ul><li>引入外观角色之后，用户<strong>只需要直接与外观角色交互</strong>，<strong>用户与子系统之间的复杂关系由外观角色来实现</strong>，从而降低了系统的耦合度。外观模式</li></ul><h4 id="模式定义-4"><a href="#模式定义-4" class="headerlink" title="模式定义"></a>模式定义</h4><ul><li>Facade Pattern：外部与一个子系统的通信必须通过一个<strong>统一的外观对象</strong>进行，为子系统中的一组接口<strong>提供一个一致的界面</strong>，外观模式定义了一个高层接口，这个接口<strong>使得这一子系统更加容易使用</strong>。外观模式又称为门面模式，它是一种<strong>对象结构型模式</strong>。<ol><li><p>简化了接口</p></li><li><p>接口相关模式：适配器模式、外观模式，变化决定了要使用哪个模式</p></li></ol></li></ul><h4 id="模式结构-4"><a href="#模式结构-4" class="headerlink" title="模式结构"></a>模式结构</h4><ul><li><p>使用的设计原则：迪米特原则、单一职责原则<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-30.png" alt="alt text"></p></li><li><p>外观模式包含如下角色：</p><ol><li><code>Facade</code>：外观角色</li><li><code>SubSystem</code>：子系统角色</li></ol></li></ul><h4 id="模式分析-4"><a href="#模式分析-4" class="headerlink" title="模式分析"></a>模式分析</h4><ul><li><p>根据“<strong>单一职责原则</strong>”，<strong>在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性</strong>，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是<strong>引入一个外观对象</strong>，它<strong>为子系统的访问提供了一个简单而单一的入口</strong>。</p></li><li><p>外观模式也是“<strong>迪米特法则</strong>”的体现，通过<strong>引入一个新的外观类可以降低原有系统的复杂度</strong>，同时<strong>降低客户类与子系统类的耦合度</strong>。</p></li><li><p>外观模式要求一个子系统的外部与其内部的通信<strong>通过一个统一的外观对象进行</strong>，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</p></li><li><p>外观模式的目的在于<strong>降低系统的复杂程度</strong>。</p></li><li><p>外观模式从很大程度上<strong>提高了客户端使用的便捷性</strong>，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</p></li><li><p>典型的外观角色代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemA</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemB</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemC</span> <span class="variable">obj3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemC</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        obj1.method();</span><br><span class="line">        obj2.method();</span><br><span class="line">        obj3.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实例分析-4"><a href="#实例分析-4" class="headerlink" title="实例分析"></a>实例分析</h4><h5 id="电源总开关"><a href="#电源总开关" class="headerlink" title="电源总开关"></a>电源总开关</h5><ul><li>现在考察一个电源总开关的例子，以便进一步说明外观模式。为了使用方便，一个电源总开关可以控制四盏灯、一个风扇、一台空调和一台电视机的启动和关闭。通过该电源总开关可以同时控制上述所有电器设备，使用外观模式设计该系统。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-31.png" alt="alt text"></li></ul><h5 id="文件加密"><a href="#文件加密" class="headerlink" title="文件加密"></a>文件加密</h5><ul><li>某系统需要提供一个文件加密模块，加密流程包括三个操作，分别是读取源文件、加密、保存加密之后的文件。读取文件和保存文件使用流来实现，这三个操作相对独立，其业务代码封装在三个不同的类中。现在需要提供一个统一的加密外观类，用户可以直接使用该加密外观类完成文件的读取、加密和保存三个操作，而不需要与每一个类进行交互，使用外观模式设计该加密模块。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-32.png" alt="alt text"></li></ul><blockquote><ol><li>可以使用模板方法模式实现吗？子类提供不同的实现，复用父类方法的步骤</li><li>什么时候外观？如果每一个部分都不变，只是提供接口</li></ol></blockquote><h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点：</p><ul><li><strong>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易</strong>。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li><li><strong>实现了子系统与客户之间的松耦合关系</strong>，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li><strong>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程</strong>，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li><strong>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类</strong>。</li></ul></li><li><p>缺点：</p><ul><li><strong>不能很好地限制客户使用子系统类</strong>，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入<strong>抽象外观类</strong>的情况下，<strong>增加新的子系统可能需要修改外观类或客户端的源代码</strong>，<strong>违背了“开闭原则”</strong>。</li></ul></li></ul><h4 id="适用环境-4"><a href="#适用环境-4" class="headerlink" title="适用环境"></a>适用环境</h4><ul><li><strong>当要为一个复杂子系统提供一个简单接口时可以使用外观模式</strong>。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li><li><strong>客户程序与多个子系统之间存在很大的依赖性</strong>。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以<strong>使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度</strong>。</li></ul><h4 id="模式应用-4"><a href="#模式应用-4" class="headerlink" title="模式应用"></a>模式应用</h4><ul><li><p>外观模式应用于 JDBC 数据库操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCFacade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(String driver, String jdbcUrl, String userName, String userPwd)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeUpdate</span><span class="params">(String sql)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ResultSet <span class="title function_">executeQuery</span><span class="params">(String sql)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Session 外观模式是外观模式在 Java EE 框架中的应用。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/sessionFacade.png" alt="img"></p></li></ul><h4 id="模式扩展-3"><a href="#模式扩展-3" class="headerlink" title="模式扩展"></a>模式扩展</h4><ul><li><p>在一个系统中<strong>可以设计多个外观类</strong>，每个外观类都负责和一些特定的子系统交互。</p></li><li><p><strong>不要通过继承一个外观类在子系统中加入新的行为</strong>，这种做法是错误的。</p></li><li><p>外观模式与迪米特法则：<strong>外观模式创造出一个外观对象，将客户端所涉及的属于一个子系统的协作伙伴的数量减到最少，使得客户端与子系统内部的对象的相互作用被外观对象所取代</strong>。</p></li><li><p>抽象外观类的引入：外观模式最大的缺点在于<strong>违背了“开闭原则”</strong>，<strong>当增加新的子系统或者移除子系统时需要修改外观类</strong>，可以<strong>通过引入抽象外观类在一定程度上解决该问题</strong>，客户端针对抽象外观类进行编程。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-33.png" alt="alt text"></p></li></ul><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote><p>整理不动了，去看ppt或者博客吧</p><p><a target="_blank" rel="noopener" href="https://eaglebear2002.github.io/2023Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1-02-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">软件详细设计-02-策略模式 | EagleBear2002 的博客</a></p></blockquote><h3 id="状态模式-State-Pattern"><a href="#状态模式-State-Pattern" class="headerlink" title="状态模式 State Pattern"></a>状态模式 State Pattern</h3><h4 id="模式动机-4"><a href="#模式动机-4" class="headerlink" title="模式动机"></a>模式动机</h4><ul><li>一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的（stateful）对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</li><li>在 UML 中可以使用状态图来描述对象状态的变化。</li></ul><h4 id="模式定义-5"><a href="#模式定义-5" class="headerlink" title="模式定义"></a>模式定义</h4><ul><li>状态模式（State Pattern）：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象（Objects for States），状态模式是一种对象行为型模式。</li><li>设计主要是面对变化，因此我们在分析开始的时候就应该分析变化：增加新的状态，面向新的状态的部分的行为。</li><li>封装变化：封闭 + 委托（组合关系）</li></ul><h4 id="模式结构-5"><a href="#模式结构-5" class="headerlink" title="模式结构"></a>模式结构</h4><ul><li><p>模式结构<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-4.png" alt="alt text"></p></li><li><p>状态模式包含如下角色：</p><ul><li><code>Context</code>: 环境类</li><li><code>State</code>: 抽象状态类</li><li><code>ConcreteState</code>: 具体状态类</li></ul></li><li><p>在结构上策略模式和状态模式是一致的，但是在使用上是很不同的</p><ul><li>Context 是状态模式关联的上下文环境。</li></ul></li></ul><h4 id="模式分析-5"><a href="#模式分析-5" class="headerlink" title="模式分析"></a>模式分析</h4><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-6.png" alt="alt text"></p><ul><li><p>状态模式的关键是<strong>引入了一个抽象类</strong>来专门表示<strong>对象的状态</strong>，这个类我们叫做<strong>抽象状态类</strong>，而对象的<strong>每一种具体状态类都继承了该类</strong>，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state == <span class="string">&quot;空闲&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (预订房间) &#123;</span><br><span class="line">        <span class="comment">// 预订操作;</span></span><br><span class="line">        state = <span class="string">&quot;已预订&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (住进房间) &#123;</span><br><span class="line">        <span class="comment">// 入住操作;</span></span><br><span class="line">        state = <span class="string">&quot;已入住&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;已预订&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (住进房间) &#123;</span><br><span class="line">        <span class="comment">// 入住操作;</span></span><br><span class="line">        state = <span class="string">&quot;已入住&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (取消预订) &#123;</span><br><span class="line">        <span class="comment">// 取消操作;</span></span><br><span class="line">        state = <span class="string">&quot;空闲&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何能够对用户透明，而避免让用户进行状态变更的设置。</p></li><li><p>使用状态模式重构之后的代码：但是下图中不符合开闭原则，下面如果添加状态则会导致内部的改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构之后的“空闲状态类”示例代码</span></span><br><span class="line"><span class="keyword">if</span> (预订房间) &#123;</span><br><span class="line">    <span class="comment">// 预订操作;</span></span><br><span class="line">    context.setState(<span class="keyword">new</span> 已预订状态类());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (住进房间) &#123;</span><br><span class="line">    <span class="comment">// 入住操作;</span></span><br><span class="line">    context.setState(<span class="keyword">new</span> 已入住状态类());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>策略模式是封装好的，而下图中为了追求对用户透明则牺牲了开闭原则。</p></li><li><p>状态模式要注意数据的分割：类的拆分，尽量将数据放在 <code>context</code> 中，状态中的信息越少越好。</p></li><li><p>需要理解环境类与抽象状态类的作用</p><ul><li>环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器（State Manager）的角色，可以在环境类中对状态进行切换操作。</li><li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件：这些状态经常需要切换，在不同的状态下对象的行为不同。</li></ul></li></ul><h4 id="实例分析-5"><a href="#实例分析-5" class="headerlink" title="实例分析"></a>实例分析</h4><h5 id="论坛用户等级"><a href="#论坛用户等级" class="headerlink" title="论坛用户等级"></a>论坛用户等级</h5><ul><li><p>在某论坛系统中，用户可以发表留言，发表留言将增加积分；用户也可以回复留言，回复留言也将增加积分；用户还可以下载文件，下载文件将扣除积分。该系统用户分为三个等级，分别是新手、高手和专家，这三个等级对应三种不同的状态，这三种状态分别</p></li><li><p>定义如下：</p><ol><li>如果积分小于 100 分，则为新手状态，用户可以发表留言、回复留言，但是不能下载文件。如果积分大于等于 1000 分，则转换为专家状态；如果积分大于等于 100 分，则转换为高手状态。</li><li>如果积分大于等于 100 分但小于 1000 分，则为高手状态，用户可以发表留言、回复留言，还可以下载文件，而且用户在发表留言时可以获取双倍积分。如果积分小于 100 分，则转换为新手状态；如果积分大于等于 1000 分，则转换为专家状态；如果下载文件后积分小于 0，则不能下载该文件。</li><li>如果积分大于等于 1000 分，则为专家状态，用户可以发表留言、回复留言和下载文件，用户除了在发表留言时可以获取双倍积分外，下载文件只扣除所需积分的一半。如果积分小于 100 分，则转换为新手状态；如果积分小于 1000 分，但大于等于 100，则转换为高手状态；如果下载文件后积分小于 0，则不能下载该文件。</li></ol><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-37.png" alt="alt text"></p></li><li><p><code>point</code> 和 <code>checkstate</code> 应该放置在外侧</p></li></ul><h4 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点：</p><ul><li>封装了<strong>转换规则</strong>。</li><li><strong>枚举可能的状态</strong>，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li><strong>允许状态转换逻辑与状态对象合成一体</strong>，而不是某一个巨大的条件语句块。</li><li>可以让<strong>多个环境对象共享一个状态对象</strong>，从而减少系统中对象的个数。</li></ul></li><li><p>缺点：</p><ul><li>状态模式的使用必然会<strong>增加系统类和对象的个数</strong>。</li><li>状态模式的结构与实现都<strong>较为复杂</strong>，如果使用不当将导致<strong>程序结构和代码的混乱</strong>。</li><li>状态模式对<strong>“开闭原则”</strong>的支持并<strong>不太好</strong>，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ul></li></ul><h4 id="适用环境-5"><a href="#适用环境-5" class="headerlink" title="适用环境"></a>适用环境</h4><ul><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li></ul><h4 id="模式应用-5"><a href="#模式应用-5" class="headerlink" title="模式应用"></a>模式应用</h4><ul><li>状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府 OA 办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。</li><li>在目前主流的 RPG（Role Play Game，角色扮演游戏）中，使用状态模式可以对游戏角色进行控制，游戏角色的升级伴随着其状态的变化和行为的变化。对于游戏程序本身也可以通过状态模式进行总控，一个游戏活动包括开始、运行、结束等状态，通过对状态的控制可以控制系统的行为，决定游戏的各个方面，因此可以使用状态模式对整个游戏的架构进行设计与实现。</li></ul><h4 id="模式扩展-4"><a href="#模式扩展-4" class="headerlink" title="模式扩展"></a>模式扩展</h4><h5 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h5><p>在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象。</p><h5 id="简单状态模式与可切换状态的状态模式"><a href="#简单状态模式与可切换状态的状态模式" class="headerlink" title="简单状态模式与可切换状态的状态模式"></a>简单状态模式与可切换状态的状态模式</h5><ul><li>简单状态模式：简单状态模式是指状态都相互独立，状态之间无须进行转换的状态模式，这是最简单的一种状态模式。对于这种状态模式，每个状态类都封装与状态相关的操作，而无须关心状态的切换，可以在客户端直接实例化状态类，然后将状态对象设置到环境类中。如果是这种简单的状态模式，它遵循“开闭原则”，在客户端可以针对抽象状态类进行编程，而将具体状态类写到配置文件中，同时增加新的状态类对原有系统也不造成任何影响。</li><li>可切换状态的状态模式：大多数的状态模式都是可以切换状态的状态模式，在实现状态切换时，在具体状态类内部需要调用环境类 <code>Context</code> 的 <code>setState()</code> 方法进行状态的转换操作，在具体状态类中可以调用到环境类的方法，因此状态类与环境类之间通常还存在关联关系或者依赖关系。通过在状态类中引用环境类的对象来回调环境类的 <code>setState()</code> 方法实现状态的切换。在这种可以切换状态的状态模式中，增加新的状态类可能需要修改其他某些状态类甚至环境类的源代码，否则系统无法切换到新增状态。</li></ul><h3 id="命令模式-Command-Pattern"><a href="#命令模式-Command-Pattern" class="headerlink" title="命令模式 Command Pattern"></a>命令模式 Command Pattern</h3><h4 id="模式动机-5"><a href="#模式动机-5" class="headerlink" title="模式动机"></a>模式动机</h4><ul><li>我们经常<strong>需要向某些对象发送请求</strong>，但是<strong>并不知道请求的接收者是谁，也不知道被请求的操作是哪个</strong>，我们<strong>只需在程序运行时指定具体的请求接收者</strong>即可，此时，可以使用命令模式来进行设计，使得<strong>请求发送者与请求接收者消除彼此之间的耦合</strong>，让对象之间的调用关系更加灵活。</li><li>命令模式可以<strong>对发送者和接收者完全解耦</strong>，发送者与接收者之间<strong>没有直接引用关系</strong>，<strong>发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</strong>。这就是命令模式的模式动机。</li></ul><h4 id="模式定义-6"><a href="#模式定义-6" class="headerlink" title="模式定义"></a>模式定义</h4><ul><li><strong>将一个请求封装为一个对象</strong>，从而使我们<strong>可用不同的请求对客户进行参数化</strong>；<strong>对请求排队或者记录请求日志</strong>，以及<strong>支持可撤销的操作</strong>。命令模式是一种<strong>对象行为型</strong>模式，其别名为动作(Action)模式或事务(Transaction)模式。</li></ul><h4 id="模式结构-6"><a href="#模式结构-6" class="headerlink" title="模式结构"></a>模式结构</h4><ul><li><p>模式结构：<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-7.png" alt="alt text"></p></li><li><p>包含的角色：</p><ul><li><code>Command</code>：抽象命令类</li><li><code>ConcreteCommand</code>：具体命令类</li><li><code>Invoker</code>：调用者</li><li><code>Receiver</code>：接收者</li><li><code>Client</code>：客户类</li></ul></li></ul><h4 id="模式分析-6"><a href="#模式分析-6" class="headerlink" title="模式分析"></a>模式分析</h4><ul><li><p>命令模式的本质是<strong>对命令进行封装</strong>，<strong>将发出命令的责任和执行命令的责任分割开</strong>。</p></li><li><p>每一个命令都是一个操作：<strong>请求的一方发出请求</strong>，要求执行一个操作；<strong>接收的一方收到请求</strong>，并执行操作。</p></li><li><p>命令模式允许请求的一方和接收的一方独立开来，<strong>使得请求的一方不必知道接收请求的一方的接口</strong>，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p></li><li><p>命令模式<strong>使请求本身成为一个对象</strong>，这个对象和其他对象一样可以被存储和传递。</p></li><li><p>命令模式的关键在于<strong>引入了抽象命令接口</strong>，且<strong>发送者针对抽象命令接口编程</strong>，只有<strong>实现了抽象命令接口的具体命令才能与接收者相关联</strong>。</p></li><li><p>典型的抽象命令类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的调用者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务方法，用于调用命令类的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的具体命令类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的请求接收者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>命令模式顺序图<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-8.png" alt="alt text"></p></li></ul><h4 id="实例分析-6"><a href="#实例分析-6" class="headerlink" title="实例分析"></a>实例分析</h4><h5 id="电视机遥控器"><a href="#电视机遥控器" class="headerlink" title="电视机遥控器"></a>电视机遥控器</h5><ul><li>电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。显然，电视机遥控器就是一个典型的命令模式应用实例。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-9.png" alt="alt text"></li></ul><h5 id="功能键设置"><a href="#功能键设置" class="headerlink" title="功能键设置"></a>功能键设置</h5><ul><li>为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，如功能键 <code>FunctionButton</code> 可以用于退出系统（<code>SystemExitClass</code>），也可以用于打开帮助界面（<code>DisplayHelpClass</code>）。用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，相同的功能键可以对应不同的功能。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-10.png" alt="alt text"></li></ul><h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点：</p><ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的 Undo 和 Redo。</li></ul></li><li><p>缺点：</p><ul><li>使用命令模式可能会导致<strong>某些系统有过多的具体命令类</strong>。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li></ul></li><li><p>模式适用坏境：</p><ul><li>系统需要<strong>将请求调用者和请求接收者解耦</strong>，使得调用者和接收者不直接交互。</li><li>系统需要<strong>在不同的时间指定请求、将请求排队和执行请求</strong>。</li><li>系统需要<strong>支持命令的撤销（Undo）操作和恢复（Redo）操作</strong>。</li><li>系统需要<strong>将一组操作组合在一起</strong>，即支持宏命令。</li></ul></li></ul><h4 id="适用环境-6"><a href="#适用环境-6" class="headerlink" title="适用环境"></a>适用环境</h4><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令。</li></ul><h4 id="模式应用-6"><a href="#模式应用-6" class="headerlink" title="模式应用"></a>模式应用</h4><ul><li>Java 语言使用命令模式实现 AWT&#x2F;Swing GUI 的委派事件模型 (Delegation Event Model, DEM)。<ul><li>在 AWT&#x2F;Swing 中，Frame、Button 等界面组件是请求发送者，而 AWT 提供的事件监听器接口和事件适配器类是抽象命令接口，用户可以自己写抽象命令接口的子类来实现事件处理，即实现具体命令类，而在具体命令类中可以调用业务处理方法来实现该事件的处理。对于界面组件而言，只需要了解命令接口即可，无须关心接口的实现，组件类并不关心实际操作，而操作由用户来实现。</li></ul></li><li>很多系统都提供了宏命令功能，如 UNIX 平台下的 Shell 编程，可以将多条命令封装在一个命令对象中，只需要一条简单的命令即可执行一个命令序列，这也是命令模式的应用实例之一。</li></ul><h4 id="模式扩展-5"><a href="#模式扩展-5" class="headerlink" title="模式扩展"></a>模式扩展</h4><h5 id="撤销操作的实现"><a href="#撤销操作的实现" class="headerlink" title="撤销操作的实现"></a>撤销操作的实现</h5><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-38.png" alt="alt text"></p><ul><li>宏命令又称为组合命令，它是命令模式和组合模式联用的产物。</li><li>宏命令也是一个具体命令，不过它包含了对其他命令对象的引用，在调用宏命令的 <code>execute()</code> 方法时，将递归调用它所包含的每个成员命令的 <code>execute()</code> 方法，一个宏命令的成员对象可以是简单命令，还可以继续是宏命令。执行一个宏命令将执行多个具体命令，从而实现对命令的批处理。</li></ul><h5 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h5><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-39.png" alt="alt text"></p><h3 id="观察者模式-Observer-Pattern"><a href="#观察者模式-Observer-Pattern" class="headerlink" title="观察者模式 Observer Pattern"></a>观察者模式 Observer Pattern</h3><h4 id="模式动机-6"><a href="#模式动机-6" class="headerlink" title="模式动机"></a>模式动机</h4><ul><li>建立一种<strong>对象与对象之间的依赖关系</strong>，一个对象<strong>发生改变时</strong>将自动通知其他对象，其他对象将相应做出反应。<ol><li>发生改变的对象称为<strong>观察目标</strong></li><li>被通知的对象称为<strong>观察者</strong></li></ol></li><li>一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以<strong>根据需要增加和删除观察者</strong>，<strong>使得系统更易于扩展</strong>，这就是观察者模式的模式动机。</li></ul><h4 id="模式结构-7"><a href="#模式结构-7" class="headerlink" title="模式结构"></a>模式结构</h4><ul><li>模式结构<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-11.png" alt="alt text"></li><li>包含的角色：<ul><li><code>Subject</code>：目标</li><li><code>ConcreteSubject</code>：具体目标</li><li><code>Observer</code>：观察者</li><li><code>ConcreteObserver</code>：具体观察者</li></ul></li></ul><h4 id="模式分析-7"><a href="#模式分析-7" class="headerlink" title="模式分析"></a>模式分析</h4><ul><li><p>观察者模式描述了<strong>如何建立对象与对象之间的依赖关系</strong>，如何构造满足这种需求的系统。</p></li><li><p>这一模式中的关键对象是观察目标和观察者，<strong>一个目标可以有任意数目的与之相依赖的观察者</strong>，一旦目标的状态发生改变，所有的观察者都将得到通知。</p></li><li><p>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅</strong>（publish-subscribe）。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。</p></li><li><p>松耦合：</p><ul><li>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。</li><li>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。</li><li>改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守，就可以自由地改变他们。</li></ul></li><li><p>回到 WeatherData</p><ul><li><p><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-12.png" alt="alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisplayElement</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>, DisplayElement &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> Subject weatherData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weatherData = weatherData;</span><br><span class="line">        weatherData.registerObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">&quot;Current conditions:&quot;</span> + temperature + <span class="string">&quot;F degrees and &quot;</span> + humidity + <span class="string">&quot;% humidity&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点：</p><ul><li>观察者模式可以<strong>实现表示层和数据逻辑层的分离</strong>，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间<strong>建立一个抽象的耦合</strong>。</li><li>观察者模式<strong>支持广播通信</strong>。</li><li>观察者模式<strong>符合“开闭原则”</strong>的要求。</li></ul></li><li><p>缺点：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，<strong>将所有的观察者都通知到会花费很多时间</strong>。</li><li>如果在观察者和观察目标之间有<strong>循环依赖</strong>的话，观察目标会触发它们之间进行循环调用，可能<strong>导致系统崩溃</strong>。</li><li>观察者模式<strong>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</strong>，而仅仅只是知道观察目标发生了变化。</li></ul></li></ul><h4 id="适用环境-7"><a href="#适用环境-7" class="headerlink" title="适用环境"></a>适用环境</h4><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A 对象的行为将影响 B 对象，B 对象的行为将影响 C 对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><h4 id="模式应用-7"><a href="#模式应用-7" class="headerlink" title="模式应用"></a>模式应用</h4><ul><li>JDK1.1 版本及以后的各个版本中，事件处理模型采用基于观察者模式的委派事件模型（Delegation Event Model, DEM）。<ul><li>在 DEM 中，事件的发布者称为事件源（Event Source），而订阅者叫做事件监听器（Event Listener），在这个过程中还可以通过事件对象（Event Object）来传递与事件相关的信息，可以在事件监听者的实现类中实现事件处理，因此事件监听对象又可以称为事件处理对象。</li><li>事件源对象、事件监听对象（事件处理对象）和事件对象构成了 Java 事件处理模型的三要素。</li></ul></li><li>除了 AWT 中的事件处理之外，Java 语言解析 XML 的技术 SAX2 以及 Servlet 技术的事件处理机制都基于 DEM，它们都是观察者模式的应用。</li><li>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</li></ul><h4 id="模式扩展-6"><a href="#模式扩展-6" class="headerlink" title="模式扩展"></a>模式扩展</h4><h5 id="Java-语言提供的对观察者模式的支持"><a href="#Java-语言提供的对观察者模式的支持" class="headerlink" title="Java 语言提供的对观察者模式的支持"></a>Java 语言提供的对观察者模式的支持</h5><ul><li>在 JDK 的 java.util 包中，提供了 Observable 类以及 Observer 接口，它们构成了 Java 语言对观察者模式的支持。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-40.png" alt="alt text"></li><li>Observer 接口: <code>void update(Observable o, Object arg);</code></li><li>Observable 类<ol><li><code>Observable()</code></li><li><code>addObserver(Observer o)</code></li><li><code>deleteObserver (Observer o)</code></li><li><code>notifyObservers()、notifyObservers(Object arg)</code></li><li><code>deleteObservers</code></li><li><code>setChanged()</code></li><li><code>clearChanged()</code></li><li><code>hasChanged()</code></li><li><code>countObservers()</code></li></ol></li></ul><h5 id="谁触发谁更新"><a href="#谁触发谁更新" class="headerlink" title="谁触发谁更新"></a>谁触发谁更新</h5><ul><li><p>目标和它的观察者依赖于通知机制来保持一致。但到底哪一个对象调用 Notify 来触发更新？此时有两个选择：</p><ol><li>Push 更新：由目标对象的状态设定操作在改变目标对象的状态后自动调用 Notify 。 这种方法的优点是客户不需要记住要在目标对象上调用 Notify 缺点是多个连续的操作会产生多次连续的更新 , 可能效率较低。</li><li>Pull 更新：让客户负责在适当的时候调用 Notify 。 这样做的优点是客户可以在一系列的状态改变完成后再一次性地触发更新 避免了不必要的中间更新。缺点是给客户增加了触发更新的责任。由于客户可能会忘记调用 Notify 这种方式较易出错。</li></ol></li></ul><h5 id="封装复杂的更新语义"><a href="#封装复杂的更新语义" class="headerlink" title="封装复杂的更新语义"></a>封装复杂的更新语义</h5><ul><li><p>当目标和观察者间的依赖关系特别复杂时 , 可能需要一个维护这些关系的对象。 我们称这样的对象为更改管理器 Change Manager。</p></li><li><p>它的目的是尽量减少观察者反映其目标的状态变化所需的工作量。例如 , 如果一个操作涉及到对几个相互依赖的目标进行改动 , 就必须保证仅在所有目标都已更改完毕后，才一次性地通知它们的观察者 而不是每个目标都通知观察者。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-41.png" alt="alt text"></p></li></ul><h5 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h5><blockquote><p><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/articles/javase/index-142890.html">Java SE Application Design With MVC</a></p></blockquote><ul><li>MVC 模式是一种架构模式，它包含三个角色：模型（Model），视图（View）和控制器（Controller）。观察者模式可以用来实现 MVC 模式，观察者模式中的观察目标就是 MVC 模式中的模型（Model），而观察者就是 MVC 中的视图（View），控制器（Controller）充当两者之间的中介者（Mediator）。当模型层的数据发生改变时，视图层将自动改变其显示内容。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-42.png" alt="alt text"></li></ul><h3 id="中介者模式-Mediator-Patter"><a href="#中介者模式-Mediator-Patter" class="headerlink" title="中介者模式 Mediator Patter"></a>中介者模式 Mediator Patter</h3><h4 id="模式动机-7"><a href="#模式动机-7" class="headerlink" title="模式动机"></a>模式动机</h4><ul><li>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：<ol><li><strong>系统结构复杂</strong>：<strong>对象之间</strong>存在大量的<strong>相互关联和调用</strong>，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li><li><strong>对象可重用性差</strong>：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li><li><strong>系统扩展性低</strong>：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li></ol></li><li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量<strong>将对象细化</strong>，使其只负责或呈现<strong>单一的职责</strong>。</li><li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，<strong>为了减少对象两两之间复杂的引用关系</strong>，<strong>使之成为一个松耦合的系统</strong>，我们需要使用<strong>中介者模式</strong>，这就是中介者模式的模式动机。</li></ul><h4 id="模式定义-7"><a href="#模式定义-7" class="headerlink" title="模式定义"></a>模式定义</h4><ul><li>Mediator Pattern：用一个中介对象来<strong>封装一系列的对象交互</strong>，中介者使各对象不需要显式地相互引用，从而使其<strong>耦合松散</strong>，而且可以<strong>独立地改变它们之间的交互</strong>。中介者模式又称为调停者模式，它是一种对象行为型模式。</li></ul><h4 id="模式结构-8"><a href="#模式结构-8" class="headerlink" title="模式结构"></a>模式结构</h4><ul><li>模式结构：<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-13.png" alt="alt text"></li><li>包含角色：<ul><li><code>Mediator</code>：抽象中介者</li><li><code>ConcreteMediator</code>：具体中介者</li><li><code>Colleague</code>：抽象同事类</li><li><code>ConcreteColleague</code>：具体同事类</li></ul></li></ul><h4 id="模式分析-8"><a href="#模式分析-8" class="headerlink" title="模式分析"></a>模式分析</h4><ul><li><p>中介者模式可以使对象之间的关系数量急剧减少</p></li><li><p>中介者承担两方面的职责：</p><ol><li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者<strong>在结构上的支持</strong>。</li><li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者<strong>在行为上的支持</strong>。</li></ol></li><li><p>典型的抽象中介者类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> ArrayList colleagues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Colleague colleague)</span> &#123;</span><br><span class="line">        colleagues.add(colleague);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的具体中介者类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">        ((Colleague) (colleagues.get(<span class="number">0</span>))).method1();</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的抽象同事类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的具体同事类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteColleague</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteColleague</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        mediator.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实例分析-7"><a href="#实例分析-7" class="headerlink" title="实例分析"></a>实例分析</h4><h5 id="虚拟聊天室"><a href="#虚拟聊天室" class="headerlink" title="虚拟聊天室"></a>虚拟聊天室</h5><ul><li>某论坛系统欲增加一个虚拟聊天室，允许论坛会员通过该聊天室进行信息交流，普通会员（CommonMember）可以给其他会员发送文本信息，钻石会员（DiamondMember）既可以给其他会员发送文本信息，还可以发送图片信息。该聊天室可以对不雅字符进行过滤，如“日”等字符；还可以对发送的图片大小进行控制。用中介者模式设计该虚拟聊天室。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-15.png" alt="alt text"></li></ul><h4 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点：</p><ul><li>简化了对象之间的交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ul></li><li><p>缺点：</p><ul><li>在具体中介者类中包含了同事之间的交互细节，可能会导致<strong>具体中介者类非常复杂</strong>，使得<strong>系统难以维护</strong>。</li></ul></li></ul><h4 id="适用环境-8"><a href="#适用环境-8" class="headerlink" title="适用环境"></a>适用环境</h4><ul><li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li></ul><h4 id="模式应用-8"><a href="#模式应用-8" class="headerlink" title="模式应用"></a>模式应用</h4><ul><li>中介者模式在事件驱动类软件中应用比较多，在设计 GUI 应用程序时，组件之间可能存在较为复杂的交互关系，一个组件的改变将影响与之相关的其他组件，此时可以使用中介者模式来对组件进行协调。</li><li>MVC 是 Java EE 的一个基本模式，此时控制器 Controller 作为一种中介者，它负责控制视图对象 View 和模型对象 Model 之间的交互。如在 Struts 中，Action 就可以作为 JSP 页面与业务对象之间的中介者。</li></ul><h4 id="模式扩展-7"><a href="#模式扩展-7" class="headerlink" title="模式扩展"></a>模式扩展</h4><ul><li>中介者模式与迪米特法则<ul><li>在中介者模式中，通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，中介者模式就是迪米特法则的一个典型应用。</li></ul></li><li>中介者模式与 GUI 开发<ul><li>中介者模式可以方便地应用于图形界面（GUI）开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系。</li><li>对于这些复杂的交互关系，有时候我们可以引入一个中介者类，将这些交互的组件作为具体的同事类，将它们之间的引用和控制关系交由中介者负责，在一定程度上简化系统的交互，这也是中介者模式的常见应用之一。</li></ul></li></ul><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><h4 id="模式动机-8"><a href="#模式动机-8" class="headerlink" title="模式动机"></a>模式动机</h4><ul><li>模板方法模式是<strong>基于继承</strong>的代码复用基本技术，模板方法模式的结构和用法也是面向对象设计的核心之一。在模板方法模式中，可以<strong>将相同的代码放在父类中，而将不同的方法实现放在不同的子类中</strong>。</li><li>在模板方法模式中，我们需要准备一个抽象类，<strong>将部分逻辑以具体方法以及具体构造函数的形式实现</strong>，然后<strong>声明一些抽象方法来让子类实现剩余的逻辑</strong>。<strong>不同的子类可以以不同的方式实现这些抽象方法</strong>，<strong>从而对剩余的逻辑有不同的实现</strong>，这就是模板方法模式的用意。模板方法模式体现了面向对象的诸多重要思想，是一种使用频率较高的模式。</li></ul><h4 id="模式定义-8"><a href="#模式定义-8" class="headerlink" title="模式定义"></a>模式定义</h4><ul><li>Template Method Pattern：定义一个操作中<strong>算法的骨架</strong>，而将一些步骤<strong>延迟到子类</strong>中，模板方法使得子类可以<strong>不改变一个算法的结构即可重定义该算法的某些特定步骤</strong>。模板方法是一种<strong>类行为型</strong>模式。</li></ul><p></p><h4 id="模式结构-9"><a href="#模式结构-9" class="headerlink" title="模式结构"></a>模式结构</h4><ul><li>模式结构<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-16.png" alt="alt text"></li><li>包含角色：<ul><li><code>AbstractClass</code>：抽象类</li><li><code>ConcreteClass</code>：具体子类</li></ul></li></ul><h4 id="模式分析-9"><a href="#模式分析-9" class="headerlink" title="模式分析"></a>模式分析</h4><ul><li><p>模板方法模式是一种类的行为型模式，在它的结构图中<strong>只有类之间的继承关系，没有对象关联关系</strong>。</p></li><li><p>在模板方法模式的使用过程中，要求开发抽象类和开发具体子类的设计师之间进行协作。一个设计师<strong>负责给出一个算法的轮廓和骨架</strong>，另一些设计师则<strong>负责给出这个算法的各个逻辑步骤</strong>。实现这些具体逻辑步骤的方法称为<strong>基本方法（Primitive Method）</strong>，而将这些基本法方法汇总起来的方法称为<strong>模板方法（Template Method）</strong>，模板方法模式的名字从此而来。</p></li><li><p>模板方法：一个模板方法是<strong>定义在抽象类中的、把基本操作方法组合在一起</strong>形成一个总算法或一个总行为的方法。</p></li><li><p>基本方法：基本方法是<strong>实现算法各个步骤的方法</strong>，是模板方法的组成部分。</p><ol><li>抽象方法（Abstract Method）</li><li>具体方法（Concrete Method）</li><li>钩子方法（Hook Method）：“挂钩”方法和空方法</li></ol></li><li><p>钩子方法（Hook Method）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">template</span><span class="params">()</span> &#123;</span><br><span class="line">    open();</span><br><span class="line">    display();</span><br><span class="line">    <span class="keyword">if</span> (isPrint()) &#123;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPrint</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的抽象类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> <span class="comment">//模板方法</span></span><br><span class="line">	&#123;</span><br><span class="line">        primitiveOperation1();</span><br><span class="line">        primitiveOperation2();</span><br><span class="line">        primitiveOperation3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation1</span><span class="params">()</span> <span class="comment">//基本方法—具体方法</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span>; <span class="comment">//基本方法—抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation3</span><span class="params">()</span> <span class="comment">//基本方法—钩子方法</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>典型的具体子类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在模板方法模式中，由于面向对象的多态性，子类对象在运行时将覆盖父类对象，子类中定义的方法也将覆盖父类中定义的方法，因此程序在运行时，<strong>具体子类的基本方法将覆盖父类中定义的基本方法</strong>，<strong>子类的钩子方法也将覆盖父类的钩子方法</strong>，从而可以<strong>通过在子类中实现的钩子方法对父类方法的执行进行约束</strong>，实现子类对父类行为的<strong>反向控制</strong>。</p></li></ul><h4 id="实例分析-8"><a href="#实例分析-8" class="headerlink" title="实例分析"></a>实例分析</h4><h5 id="银行业务办理流程"><a href="#银行业务办理流程" class="headerlink" title="银行业务办理流程"></a>银行业务办理流程</h5><ul><li>在银行办理业务时，一般都包含几个基本步骤，首先需要取号排队，然后办理具体业务，最后需要对银行工作人员进行评分。无论具体业务是取款、存款还是转账，其基本流程都一样。现使用模板方法模式模拟银行业务办理流程。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-17.png" alt="alt text"></li></ul><h5 id="数据库操作模板"><a href="#数据库操作模板" class="headerlink" title="数据库操作模板"></a>数据库操作模板</h5><ul><li>对数据库的操作一般包括连接、打开、使用、关闭等步骤，在数据库操作模板类中我们定义了 <code>connDB()</code>、<code>openDB()</code>、<code>useDB()</code>、<code>closeDB()</code>四个方法分别对应这四个步骤。对于不同类型的数据库（如 SQL Server 和 Oracle），其操作步骤都一致，只是连接数据库 <code>connDB()</code> 方法有所区别，现使用模板方法模式对其进行设计。<br><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/software_design/image-43.png" alt="alt text"></li></ul><h4 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点：</p><ul><li>模板方法模式<strong>在一个类中抽象地定义算法</strong>，而由它的<strong>子类实现细节的处理</strong>。</li><li>模板方法模式是一种<strong>代码复用</strong>的基本技术。</li><li>模板方法模式导致一种<strong>反向的控制结构</strong>，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，<strong>符合“开闭原则”</strong>。</li></ul></li><li><p>缺点：</p><ul><li>每个不同的实现都需要定义一个子类，这会<strong>导致类的个数增加</strong>，系统更加庞大，设计也更加抽象，但是更加<strong>符合“单一职责原则”</strong>，使得类的内聚性得以提高。</li></ul></li></ul><h4 id="适用环境-9"><a href="#适用环境-9" class="headerlink" title="适用环境"></a>适用环境</h4><ul><li>一次性实现一个算法的不变的部分，并将<strong>可变的行为留给子类来实现</strong>。</li><li><strong>各子类中公共的行为应被提取出来</strong>并集中到一个公共父类中以避免代码重复。</li><li><strong>对一些复杂的算法进行分割</strong>，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。</li><li><strong>控制子类的扩展</strong>。</li></ul><h4 id="模式应用-9"><a href="#模式应用-9" class="headerlink" title="模式应用"></a>模式应用</h4><ul><li>模板方法模式广泛应用于框架设计（如Spring，Struts等）中，以<strong>确保父类控制处理流程的逻辑顺序</strong>（如框架的初始化）。</li><li>Java 单元测试工具 JUnit 中的 <code>TestCase</code>类的设计：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Java 单元测试工具 JUnit 中的 TestCase 类的设计：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runBare</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">   setUp();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      runTest();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      tearDown();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="模式扩展-8"><a href="#模式扩展-8" class="headerlink" title="模式扩展"></a>模式扩展</h4><ul><li>关于继承的讨论：模板方法模式鼓励我们恰当使用继承，此模式可以用来改写一些拥有相同功能的相关类，将可复用的一般性的行为代码移到父类里面，而将特殊化的行为代码移到子类里面。这也进一步说明，虽然继承复用存在一些问题，但是在某些情况下还是可以给开发人员带来方便，模板方法模式就是体现继承优势的模式之一。</li><li>好莱坞原则：<ul><li>在模板方法模式中，子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，父类控制对子类的调用，这种机制被称为好莱坞原则（Hollywood Principle），好莱坞原则的定义为：“不要给我们打电话，我们会给你打电话（Don‘t call us, we’ll call you）”。</li><li>在模板方法模式中，好莱坞原则体现在：子类不需要调用父类，而通过父类来调用子类，将某些步骤的实现写在子类中，由父类来控制整个过程。</li></ul></li><li>钩子方法的使用<ul><li>钩子方法的引入使得子类可以控制父类的行为。</li><li>最简单的钩子方法就是空方法，也可以在钩子方法中定义一个默认的实现，如果子类不覆盖钩子方法，则执行父类的默认实现代码。</li><li>比较复杂一点的钩子方法可以对其他方法进行约束，这种钩子方法通常返回一个 boolean 类型，即返回 true 或 false，用来判断是否执行某一个基本方法。</li></ul></li></ul><h2 id="PPT中问题"><a href="#PPT中问题" class="headerlink" title="PPT中问题"></a>PPT中问题</h2><h3 id="在-JDK-中，java-util-Stack-是-java-util-Vector-类的子类，该设计合理吗？若不合理，请分析解释该设计存在的问题。"><a href="#在-JDK-中，java-util-Stack-是-java-util-Vector-类的子类，该设计合理吗？若不合理，请分析解释该设计存在的问题。" class="headerlink" title="在 JDK 中，java.util.Stack 是 java.util.Vector 类的子类，该设计合理吗？若不合理，请分析解释该设计存在的问题。"></a>在 JDK 中，<code>java.util.Stack</code> 是 <code>java.util.Vector</code> 类的子类，该设计合理吗？若不合理，请分析解释该设计存在的问题。</h3><p>在 JDK 中，确实存在 <code>java.util.Stack</code> 是 <code>java.util.Vector</code> 类的子类的设计。这种设计在早期的 Java 开发中是合理的，但在当前的软件工程实践中，这种继承关系通常被认为是不合理或不推荐的，主要原因如下：</p><ol><li><strong>设计用途的不匹配</strong>：<ul><li><code>Vector</code> 是一个动态数组，它支持自动扩容和随机访问，而 <code>Stack</code> 是一种后进先出（LIFO）的数据结构。虽然可以通过 <code>Vector</code> 的方法实现 <code>Stack</code> 的功能，但这并不是 <code>Vector</code> 最主要的设计目标，因此使用 <code>Vector</code> 作为 <code>Stack</code> 的基类可能会导致功能上的混淆。</li></ul></li><li><strong>接口暴露的问题</strong>：<ul><li><code>Vector</code> 是一个线程安全的类，而 <code>Stack</code> 继承自 <code>Vector</code>，因此继承了 <code>Vector</code> 的所有同步方法，这包括对整个栈的操作进行同步处理。然而，在实际应用中，通常并不需要 <code>Stack</code> 的所有操作都是线程安全的，因此这种继承可能会带来额外的开销和复杂性。</li></ul></li><li><strong>继承与组合的选择</strong>：<ul><li>在软件设计中，通常推荐使用组合而不是继承来实现功能的复用。将 <code>Vector</code> 作为 <code>Stack</code> 的基类，意味着 <code>Stack</code> 继承了 <code>Vector</code> 的所有公共方法和实现细节，这可能导致不必要的耦合和限制。更好的做法是使用组合，即在 <code>Stack</code> 内部使用 <code>Vector</code> 或其他合适的数据结构来实现自己的功能，从而更灵活地管理和扩展。</li></ul></li><li><strong>过时的设计选择</strong>：<ul><li>随着时间的推移，Java 在集合框架和并发性能方面有了显著的进步和优化。<code>Vector</code> 和 <code>Stack</code> 是 Java 集合框架的旧部分，现在更推荐使用更现代和更高效的集合类，例如 <code>ArrayList</code> 或 <code>ArrayDeque</code>，它们分别用于动态数组和栈的实现，并且不会带来 <code>Vector</code> 继承中的同步开销。</li></ul></li></ol><p>综上所述，虽然 <code>Stack</code> 继承自 <code>Vector</code> 在早期的 Java 设计中是合理的，但在现代的软件开发实践中，这种设计不再被推荐。更好的做法是通过组合和选择更合适的数据结构来实现 <code>Stack</code> 的功能，以获得更好的性能和更清晰的设计。</p><h2 id="其他设计模式总结"><a href="#其他设计模式总结" class="headerlink" title="其他设计模式总结"></a>其他设计模式总结</h2><blockquote><p>by Zhy</p></blockquote><h3 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h3><div class="row"><embed src="/pdf/软件系统设计-设计模式-设计模式原则.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="具体设计模式"><a href="#具体设计模式" class="headerlink" title="具体设计模式"></a>具体设计模式</h3><div class="row"><embed src="/pdf/软件系统设计-设计模式-具体设计模式.pdf" width="100%" height="550" type="application/pdf"></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://fredqinhz.github.io">Fred Qin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://fredqinhz.github.io/posts/5db50ef3.html">https://fredqinhz.github.io/posts/5db50ef3.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fredqinhz.github.io" target="_blank">Fred's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://fredq.oss-cn-nanjing.aliyuncs.com/others/weixinpay.jpg" target="_blank"><img class="post-qr-code-img" src="https://fredq.oss-cn-nanjing.aliyuncs.com/others/weixinpay.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://fredq.oss-cn-nanjing.aliyuncs.com/others/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="https://fredq.oss-cn-nanjing.aliyuncs.com/others/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/45e5109.html" title="架构设计复习及习题总结"><img class="cover" src="https://fredq.oss-cn-nanjing.aliyuncs.com/cover/cover0.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">架构设计复习及习题总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/ab6f1cb2.html" title="架构设计部分大纲"><img class="cover" src="https://fredq.oss-cn-nanjing.aliyuncs.com/cover/cover0.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">架构设计部分大纲</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/45e5109.html" title="架构设计复习及习题总结"><img class="cover" src="https://fredq.oss-cn-nanjing.aliyuncs.com/cover/cover0.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-19</div><div class="title">架构设计复习及习题总结</div></div></a></div><div><a href="/posts/ab6f1cb2.html" title="架构设计部分大纲"><img class="cover" src="https://fredq.oss-cn-nanjing.aliyuncs.com/cover/cover0.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-19</div><div class="title">架构设计部分大纲</div></div></a></div><div><a href="/posts/d7c515c7.html" title="软件质量管理-往年卷"><img class="cover" src="https://fredq.oss-cn-nanjing.aliyuncs.com/cover/cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-19</div><div class="title">软件质量管理-往年卷</div></div></a></div><div><a href="/posts/3d5fd5b5.html" title="软件质量管理-复习"><img class="cover" src="https://fredq.oss-cn-nanjing.aliyuncs.com/cover/cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-19</div><div class="title">软件质量管理-复习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fredq.oss-cn-nanjing.aliyuncs.com/others/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Fred Qin</div><div class="author-info__description">南京大学软件工程专业 21级本科生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FredQinhz/FredQinhz.github.io"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://tool.gljlw.com/qqq/?qq=814532396" target="_blank" title="QQ：814532396"><i class="fab fa-qq" style="color:#09f"></i></a><a class="social-icon" href="https://fredq.oss-cn-nanjing.aliyuncs.com/others/weixin.jpg" target="_blank" title="微信：Q_y_tiao"><i class="fab fa-weixin" style="color:#07c160"></i></a><a class="social-icon" href="https://git.nju.edu.cn/y_tiao" target="_blank" title="南大GitLab"><i class="fab fa-gitlab" style="color:#e24329"></i></a><a class="social-icon" href="https://space.bilibili.com/2039062003" target="_blank" title="bilibili 哔哩哔哩：y_tiao"><i class="iconfont icon-bilibili"></i></a><a class="social-icon" href="https://v.douyin.com/irFDtVGh/ 4@0.com :0pm" target="_blank" title="抖音：208784591"><i class="iconfont icon-douyinzhanghao"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">软件模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">设计模式的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-number">2.2.</span> <span class="toc-text">设计模式的基本要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">设计模式的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%B1%BB%E5%BA%93%E6%A1%86%E6%9E%B6"><span class="toc-number">2.4.</span> <span class="toc-text">设计模式与类库框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.5.</span> <span class="toc-text">设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.6.</span> <span class="toc-text">设计原则之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95%EF%BC%88%E4%B8%8D%E8%80%83%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">表驱动法（不考）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%B1%BB%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">工厂方法模式（类模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">抽象工厂模式（对象模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-Prototype-Pattern"><span class="toc-number">4.3.</span> <span class="toc-text">原型模式 Prototype Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.2.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-number">4.3.3.</span> <span class="toc-text">模式分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.3.4.</span> <span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E4%B8%80%EF%BC%9A%E9%82%AE%E4%BB%B6%E5%A4%8D%E5%88%B6%EF%BC%88%E6%B5%85%E5%85%8B%E9%9A%86%EF%BC%89"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">实例一：邮件复制（浅克隆）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.3.5.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">4.3.6.</span> <span class="toc-text">适用环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-number">4.3.7.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E5%8E%9F%E5%9E%8B%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.7.1.</span> <span class="toc-text">带原型管理器的原型模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E4%BC%BC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">4.3.7.2.</span> <span class="toc-text">相似对象的复制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.8.</span> <span class="toc-text">模式应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-Adapter-Pattern"><span class="toc-number">5.1.</span> <span class="toc-text">适配器模式 Adapter Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-number">5.1.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-1"><span class="toc-number">5.1.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-1"><span class="toc-number">5.1.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90-1"><span class="toc-number">5.1.4.</span> <span class="toc-text">模式分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-1"><span class="toc-number">5.1.5.</span> <span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BF%E7%94%9F%E6%9C%BA%E5%99%A8%E4%BA%BA"><span class="toc-number">5.1.5.1.</span> <span class="toc-text">仿生机器人</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">5.1.5.2.</span> <span class="toc-text">加密适配器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">5.1.6.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-1"><span class="toc-number">5.1.7.</span> <span class="toc-text">适用环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8-1"><span class="toc-number">5.1.8.</span> <span class="toc-text">模式应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-Composite-Pattern"><span class="toc-number">5.2.</span> <span class="toc-text">组合模式 Composite Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-2"><span class="toc-number">5.2.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-2"><span class="toc-number">5.2.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90-2"><span class="toc-number">5.2.4.</span> <span class="toc-text">模式分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-2"><span class="toc-number">5.2.5.</span> <span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B0%B4%E6%9E%9C%E7%9B%98"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">水果盘</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">文件浏览</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-number">5.2.6.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-2"><span class="toc-number">5.2.7.</span> <span class="toc-text">适用环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8-2"><span class="toc-number">5.2.8.</span> <span class="toc-text">模式应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-1"><span class="toc-number">5.2.9.</span> <span class="toc-text">模式扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-Decorator-Pattern"><span class="toc-number">5.3.</span> <span class="toc-text">装饰模式 Decorator Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-2"><span class="toc-number">5.3.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-3"><span class="toc-number">5.3.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-3"><span class="toc-number">5.3.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90-3"><span class="toc-number">5.3.4.</span> <span class="toc-text">模式分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-3"><span class="toc-number">5.3.5.</span> <span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E5%BD%A2%E9%87%91%E5%88%9A%EF%BC%88%E5%8D%8A%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">5.3.5.1.</span> <span class="toc-text">变形金刚（半透明装饰模式）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">5.3.5.2.</span> <span class="toc-text">多重加密系统（透明装饰模式）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="toc-number">5.3.6.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-3"><span class="toc-number">5.3.7.</span> <span class="toc-text">适用环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8-3"><span class="toc-number">5.3.8.</span> <span class="toc-text">模式应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-2"><span class="toc-number">5.3.9.</span> <span class="toc-text">模式扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-Facade-Pattern"><span class="toc-number">5.4.</span> <span class="toc-text">外观模式 Facade Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-3"><span class="toc-number">5.4.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-4"><span class="toc-number">5.4.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-4"><span class="toc-number">5.4.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90-4"><span class="toc-number">5.4.4.</span> <span class="toc-text">模式分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-4"><span class="toc-number">5.4.5.</span> <span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%B5%E6%BA%90%E6%80%BB%E5%BC%80%E5%85%B3"><span class="toc-number">5.4.5.1.</span> <span class="toc-text">电源总开关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86"><span class="toc-number">5.4.5.2.</span> <span class="toc-text">文件加密</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-4"><span class="toc-number">5.4.6.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-4"><span class="toc-number">5.4.7.</span> <span class="toc-text">适用环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8-4"><span class="toc-number">5.4.8.</span> <span class="toc-text">模式应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-3"><span class="toc-number">5.4.9.</span> <span class="toc-text">模式扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-State-Pattern"><span class="toc-number">6.2.</span> <span class="toc-text">状态模式 State Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-4"><span class="toc-number">6.2.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-5"><span class="toc-number">6.2.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-5"><span class="toc-number">6.2.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90-5"><span class="toc-number">6.2.4.</span> <span class="toc-text">模式分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-5"><span class="toc-number">6.2.5.</span> <span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BA%E5%9D%9B%E7%94%A8%E6%88%B7%E7%AD%89%E7%BA%A7"><span class="toc-number">6.2.5.1.</span> <span class="toc-text">论坛用户等级</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-5"><span class="toc-number">6.2.6.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-5"><span class="toc-number">6.2.7.</span> <span class="toc-text">适用环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8-5"><span class="toc-number">6.2.8.</span> <span class="toc-text">模式应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-4"><span class="toc-number">6.2.9.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.9.1.</span> <span class="toc-text">共享模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%AF%E5%88%87%E6%8D%A2%E7%8A%B6%E6%80%81%E7%9A%84%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.9.2.</span> <span class="toc-text">简单状态模式与可切换状态的状态模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-Command-Pattern"><span class="toc-number">6.3.</span> <span class="toc-text">命令模式 Command Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-5"><span class="toc-number">6.3.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-6"><span class="toc-number">6.3.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-6"><span class="toc-number">6.3.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90-6"><span class="toc-number">6.3.4.</span> <span class="toc-text">模式分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-6"><span class="toc-number">6.3.5.</span> <span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%B5%E8%A7%86%E6%9C%BA%E9%81%A5%E6%8E%A7%E5%99%A8"><span class="toc-number">6.3.5.1.</span> <span class="toc-text">电视机遥控器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E9%94%AE%E8%AE%BE%E7%BD%AE"><span class="toc-number">6.3.5.2.</span> <span class="toc-text">功能键设置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-6"><span class="toc-number">6.3.6.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-6"><span class="toc-number">6.3.7.</span> <span class="toc-text">适用环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8-6"><span class="toc-number">6.3.8.</span> <span class="toc-text">模式应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-5"><span class="toc-number">6.3.9.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.9.1.</span> <span class="toc-text">撤销操作的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">6.3.9.2.</span> <span class="toc-text">宏命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-Observer-Pattern"><span class="toc-number">6.4.</span> <span class="toc-text">观察者模式 Observer Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-6"><span class="toc-number">6.4.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-7"><span class="toc-number">6.4.2.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90-7"><span class="toc-number">6.4.3.</span> <span class="toc-text">模式分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-7"><span class="toc-number">6.4.4.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-7"><span class="toc-number">6.4.5.</span> <span class="toc-text">适用环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8-7"><span class="toc-number">6.4.6.</span> <span class="toc-text">模式应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-6"><span class="toc-number">6.4.7.</span> <span class="toc-text">模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-%E8%AF%AD%E8%A8%80%E6%8F%90%E4%BE%9B%E7%9A%84%E5%AF%B9%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">6.4.7.1.</span> <span class="toc-text">Java 语言提供的对观察者模式的支持</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%81%E8%A7%A6%E5%8F%91%E8%B0%81%E6%9B%B4%E6%96%B0"><span class="toc-number">6.4.7.2.</span> <span class="toc-text">谁触发谁更新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%A4%8D%E6%9D%82%E7%9A%84%E6%9B%B4%E6%96%B0%E8%AF%AD%E4%B9%89"><span class="toc-number">6.4.7.3.</span> <span class="toc-text">封装复杂的更新语义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MVC-%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.7.4.</span> <span class="toc-text">MVC 模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-Mediator-Patter"><span class="toc-number">6.5.</span> <span class="toc-text">中介者模式 Mediator Patter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-7"><span class="toc-number">6.5.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-7"><span class="toc-number">6.5.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-8"><span class="toc-number">6.5.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90-8"><span class="toc-number">6.5.4.</span> <span class="toc-text">模式分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-7"><span class="toc-number">6.5.5.</span> <span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">6.5.5.1.</span> <span class="toc-text">虚拟聊天室</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-8"><span class="toc-number">6.5.6.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-8"><span class="toc-number">6.5.7.</span> <span class="toc-text">适用环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8-8"><span class="toc-number">6.5.8.</span> <span class="toc-text">模式应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-7"><span class="toc-number">6.5.9.</span> <span class="toc-text">模式扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.6.</span> <span class="toc-text">模板方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-8"><span class="toc-number">6.6.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-8"><span class="toc-number">6.6.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-9"><span class="toc-number">6.6.3.</span> <span class="toc-text">模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90-9"><span class="toc-number">6.6.4.</span> <span class="toc-text">模式分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-8"><span class="toc-number">6.6.5.</span> <span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1%E5%8A%9E%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">6.6.5.1.</span> <span class="toc-text">银行业务办理流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.6.5.2.</span> <span class="toc-text">数据库操作模板</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-9"><span class="toc-number">6.6.6.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83-9"><span class="toc-number">6.6.7.</span> <span class="toc-text">适用环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8-9"><span class="toc-number">6.6.8.</span> <span class="toc-text">模式应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-8"><span class="toc-number">6.6.9.</span> <span class="toc-text">模式扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PPT%E4%B8%AD%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">PPT中问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-JDK-%E4%B8%AD%EF%BC%8Cjava-util-Stack-%E6%98%AF-java-util-Vector-%E7%B1%BB%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%8C%E8%AF%A5%E8%AE%BE%E8%AE%A1%E5%90%88%E7%90%86%E5%90%97%EF%BC%9F%E8%8B%A5%E4%B8%8D%E5%90%88%E7%90%86%EF%BC%8C%E8%AF%B7%E5%88%86%E6%9E%90%E8%A7%A3%E9%87%8A%E8%AF%A5%E8%AE%BE%E8%AE%A1%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">7.1.</span> <span class="toc-text">在 JDK 中，java.util.Stack 是 java.util.Vector 类的子类，该设计合理吗？若不合理，请分析解释该设计存在的问题。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">其他设计模式总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99"><span class="toc-number">8.1.</span> <span class="toc-text">设计模式原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">具体设计模式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4e00debc.html" title="内蒙古乌兰布统沿线自驾">内蒙古乌兰布统沿线自驾</a><time datetime="2024-09-25T04:26:30.000Z" title="发表于 2024-09-25 12:26:30">2024-09-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/cd441b.html" title="25级南京大学工程硕博专项 —— 中国华电">25级南京大学工程硕博专项 —— 中国华电</a><time datetime="2024-09-23T07:00:30.000Z" title="发表于 2024-09-23 15:00:30">2024-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/848707c1.html" title="中国科学院软件研究所预推免记录">中国科学院软件研究所预推免记录</a><time datetime="2024-09-13T07:00:30.000Z" title="发表于 2024-09-13 15:00:30">2024-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/718e1ac3.html" title="Promise 对象">Promise 对象</a><time datetime="2024-09-03T04:00:00.000Z" title="发表于 2024-09-03 12:00:00">2024-09-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/a03e68d3.html" title="回调函数">回调函数</a><time datetime="2024-08-22T02:10:30.000Z" title="发表于 2024-08-22 10:10:30">2024-08-22</time></div></div></div></div></div></div></main><footer id="footer" style="background:0 0"><div id="footer-wrap"><div class="copyright">&copy;2024 By Fred Qin</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to <a href="https://fredqinhz.github.io/">Fred's blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>